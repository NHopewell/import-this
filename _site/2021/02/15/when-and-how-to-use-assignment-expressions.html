<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>‘y walrus z’: when and why should you use assignment expressions? | import-this</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="‘y walrus z’: when and why should you use assignment expressions?" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Assignment expressions, also known as the walrus operator (y := z) was a proposal in PEP 572 by . The expression above is pronounced “y walrus z”, and it allows you to assign values to variables as part of larger expressions where, before Python 3.8, you previously could not. By the way, it’s called the walrus operator because it looks like the eyes and tusks of a walrus" />
<meta property="og:description" content="Assignment expressions, also known as the walrus operator (y := z) was a proposal in PEP 572 by . The expression above is pronounced “y walrus z”, and it allows you to assign values to variables as part of larger expressions where, before Python 3.8, you previously could not. By the way, it’s called the walrus operator because it looks like the eyes and tusks of a walrus" />
<link rel="canonical" href="/import-this/2021/02/15/when-and-how-to-use-assignment-expressions.html" />
<meta property="og:url" content="/import-this/2021/02/15/when-and-how-to-use-assignment-expressions.html" />
<meta property="og:site_name" content="import-this" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-02-15T10:26:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="‘y walrus z’: when and why should you use assignment expressions?" />
<script type="application/ld+json">
{"headline":"‘y walrus z’: when and why should you use assignment expressions?","dateModified":"2021-02-15T10:26:00-05:00","url":"/import-this/2021/02/15/when-and-how-to-use-assignment-expressions.html","datePublished":"2021-02-15T10:26:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"/import-this/2021/02/15/when-and-how-to-use-assignment-expressions.html"},"description":"Assignment expressions, also known as the walrus operator (y := z) was a proposal in PEP 572 by . The expression above is pronounced “y walrus z”, and it allows you to assign values to variables as part of larger expressions where, before Python 3.8, you previously could not. By the way, it’s called the walrus operator because it looks like the eyes and tusks of a walrus","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/import-this/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/import-this/feed.xml" title="import-this" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/import-this/">import-this</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/import-this/about.html">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">&#39;y walrus z&#39;: when and why should you use assignment expressions?</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-02-15T10:26:00-05:00" itemprop="datePublished">Feb 15, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Assignment expressions, also known as the walrus operator (<code class="language-plaintext highlighter-rouge">y := z</code>) was a proposal in <a href="https://www.python.org/dev/peps/pep-0572/" target="_blank">PEP 572</a> by . The expression above is pronounced “<em>y walrus z</em>”, and it allows you to assign values to variables as part of larger expressions where, before Python 3.8, you previously could not. By the way, it’s called the walrus operator because it looks like the eyes and tusks of a <a href="https://en.wikipedia.org/wiki/Walrus#/media/File:Pacific_Walrus_-_Bull_(8247646168).jpg" target="_blank">walrus</a></p>

<p>At the time, the walrus operator was met with a lot of controversy. During the proposal of the walrus operator in PEP 572, some people argued that assignment expressions were bad and not Pythonic. These people really pushed back and claimed that <em>they</em> knew what was Pythonic and what was not. “Assignment expressions are NOT pythonic!” they exclaimed loudly.</p>

<p>When PEP 572 was proposed, Guido Van Rossum was the BDFL (Benevolent Dictator For Life) of Python. And he disagreed with them. He believed that the walrus operator was a good addition and that it was, in fact, very Pythonic. He ought to know… He created the language after all. Guido went ahead and approved PEP 572, including the walrus operator.</p>

<p>But by then the oppinions of the contributing Python developers had added a lot of stress and difficulty to Guidos life. He knew this was not the first time he had faced such opposition, and certaintly not the last time either. He decided it was time to let others handle the job. Guido promptly stepped down as BDFL the very next morning.</p>

<p>This makes the walrus operator one of the most interesting and important PEP proposals in Pythons history. So let’s look into assignment expressions and make our own conclusion: was Guido right? Or was his opposition right? Is the walrus operator any good?</p>

<p>As previously stated, the walrus operator allows the developer to assign values to variables in places where assignment was previously not allowed. The most common being within an <code class="language-plaintext highlighter-rouge">if</code> statement. Let’s look at some common patterns and use cases which could benefit from the walrus operator. By common patterns I mean scenarios which frequently come up during development.</p>

<h3 id="pattern--1">Pattern # 1</h3>
<p>The first common pattern involves any circumstance we need to read from a variable, check if its value is non-zero, and then use that value. Let’s pretend we work at a burrito shop and we are serving customers. First, let’s initialize the current stock of our different burritos:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">burrito_stock</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'beef'</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="s">'chicken'</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span>
    <span class="s">'black_bean'</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span>
    <span class="s">'veggie'</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span>
    <span class="s">'tofu'</span><span class="p">:</span> <span class="mi">8</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Let’s say a customer comes in and wants to buy a beef burrito. First, we need to check if we have a beef burrito to sell, and if we do, we can make it up for her/him to eat. We could do this by getting count of our current stock of beef burritos and then checking for a non-zero value with an <code class="language-plaintext highlighter-rouge">if</code> statement:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">make_beef_burrito</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
    <span class="p">...</span>
<span class="k">def</span> <span class="nf">out_of_stock</span><span class="p">():</span>
    <span class="p">...</span>

<span class="n">count</span> <span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'beef'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">if</span> <span class="n">count</span><span class="p">:</span>
    <span class="n">beef_burrito</span> <span class="o">=</span> <span class="n">make_beef_burrito</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">out_of_stock</span><span class="p">()</span>
</code></pre></div></div>
<p>We can see this code may be misleading because it’s easy to assume that the count variable is accessed in both the <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">else</code> branches. Because count is declared at the top, but is only used in the <code class="language-plaintext highlighter-rouge">if</code> branch, we might mistake it for being more important than it actually is.</p>

<p>Assignment expressions make this exact scenario cleaner. Here is the same example with the walrus operator:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">count</span> <span class="p">:</span><span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'beef'</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">beef_burrito</span> <span class="o">=</span> <span class="n">make_beef_burrito</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">out_of_stock</span><span class="p">()</span>
</code></pre></div></div>
<p>Now it becomes very clear where the count variable is being used. It is more obvious at a glance that count is relevant to the <code class="language-plaintext highlighter-rouge">if</code> statement. This two step process of assigning and then evaluating is the core concept behind the walrus operator.</p>

<p>If we continue with this scenario, let’s pretend to make one veggie burrito we need 2 rations of veggies instead of just one. We would now need to do a comparison inside the <code class="language-plaintext highlighter-rouge">if</code> statement. Without the walrus operator, that would look like this:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">make_veggie_burrito</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
    <span class="p">...</span>


<span class="n">count</span> <span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'veggie'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">veggie_burrito</span> <span class="o">=</span> <span class="n">make_veggie_burrito</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">out_of_stock</span><span class="p">()</span>

</code></pre></div></div>
<p>This presents the same problem of over emphasizing the count variable. We can clean this up again by making it clear where count is important with the walrus operator:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="p">:</span><span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'veggie'</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">veggie_burrito</span> <span class="o">=</span> <span class="n">make_veggie_burrito</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">out_of_stock</span><span class="p">()</span>
</code></pre></div></div>
<p>It is important to note that when our assignment expression is a subexpression of a larger expression, like above, we need to wrap it in parentheses. In any case where we do not need the parentheses they should be dropped entirely. This goes for any subexpression in Python, not only ones which contain the walrus operator.</p>

<h3 id="pattern--2">Pattern # 2</h3>
<p>The second common pattern, which is similar to the first pattern, involves anytime we want to assign a value to a variable depending on some condition, and then use that variable in a function call right after. Let’s continue with the veggie burrito customer. Let’s say in order to fulfill the order I need the 2 portions of veggies (like before) to be sliced up, and if we don’t have enough veggies to slice, I want to raise an OutOfVeggies exception. Here is a way to implement this scenario without the walrus operator:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">make_veggie_burrito</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
    <span class="p">...</span>

<span class="k">def</span> <span class="nf">slice_veggies</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
    <span class="p">...</span>

<span class="k">class</span> <span class="nc">OutOfVeggies</span><span class="p">(</span><span class="nb">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">slices</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'veggie'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">slice_veggies</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">veggie_burrito</span> <span class="o">=</span> <span class="n">make_veggie_burrito</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">OutOfVeggies</span><span class="p">:</span>
        <span class="n">out_of_stock</span><span class="p">()</span>
</code></pre></div></div>
<p>Now we can see the potential confusion really begin to arise. We see slices and count initialized above the branching logic, and at first glance we might think they are both important to all the logic below. In reality, only slices is important outside the <code class="language-plaintext highlighter-rouge">if</code> condition, count is only used in the call to <code class="language-plaintext highlighter-rouge">slice_veggies()</code>. Let’s rework with with the walrus operator:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">slices</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'veggie'</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">slice_veggies</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">veggie_burrito</span> <span class="o">=</span> <span class="n">make_veggie_burrito</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">OutOfVeggies</span><span class="p">:</span>
        <span class="n">out_of_stock</span><span class="p">()</span>
</code></pre></div></div>
<p>Now it is much more clear that slices is relevant to all the logic below the line where it is declared, and count is only important to the <code class="language-plaintext highlighter-rouge">if</code> statement. At a glance, we understand the scope of importance of these two variables and any room for ambiguity has gone away.</p>

<h3 id="pattern--3">Pattern # 3</h3>
<p>The third common pattern involves scenarios where a switch/case statement might be a programmers first choice when tackling some sub problem they face, but she/he cant’ use one because Python does not support switches (as of yet). Typically, Python developers handle this with nesting multiple <code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">elif</code>, and <code class="language-plaintext highlighter-rouge">else</code> statements.</p>

<p>Let’s pretend that we want to automate buritto making for our non-meat eating customers. We can see that 3 of our options in our stock do not contain meat. These are veggie, black bean, and tofu burritos. Let’s say that we know veggie is the most popular, then black bean, then tofu. And each of these options requires a different amount of each ingredient to make. Our system might look like this:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">count</span> <span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'veggie'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">slice_veggies</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
    <span class="n">burrito</span> <span class="o">=</span> <span class="n">make_veggie_burrito</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'black_bean'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">burrito</span> <span class="o">=</span> <span class="n">make_black_bean_burrito</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'tofu'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
           <span class="n">burrito</span> <span class="o">=</span> <span class="n">make_tofu_burrito</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">burrito</span> <span class="o">=</span> <span class="s">"No burrito for you, bosss."</span>
</code></pre></div></div>
<p>This type of nested code is quite common in Python because of the lack of a switch statement. But when we clean this up with the walrus operator, it almost feels like we are suddenly using a switch statement:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="p">:</span><span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'veggie'</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">slice_veggies</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
    <span class="n">burrito</span> <span class="o">=</span> <span class="n">make_veggie_burrito</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
<span class="k">elif</span> <span class="p">(</span><span class="n">count</span> <span class="p">:</span><span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'black_bean'</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">burrito</span> <span class="o">=</span> <span class="n">make_black_bean_burrito</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
<span class="k">elif</span> <span class="p">(</span><span class="n">count</span> <span class="p">:</span><span class="o">=</span> <span class="n">burrito_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'tofu'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
    <span class="n">burrito</span> <span class="o">=</span> <span class="n">make_tofu_burrito</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">burrito</span> <span class="o">=</span> <span class="s">"No burrito for you, bosss."</span>
</code></pre></div></div>
<p>We have stripped out all the nesting statements and it is obvious now what is happening in this bit of code. In situations where ugly nested branching logic is showing up in your code, it is probably worth your time to consider reimplementing the logic using assignment expressions.</p>

<p>That being said, it was recently announced that <a target="_blank" href="https://github.com/gvanrossum/patma">switch statements will be coming to Python soon</a>. This proposal has been approved as of <a href="https://www.python.org/dev/peps/pep-0634/" target="_blank">PEP 634</a>. It seems the Python switch will be much more powerful than switch implementations in other languages like C#. If you’re reading in the future, maybe this has already been released. I imagine these proper switch statements will be the preferred solution to this common pattern we just discussed.</p>

<h3 id="pattern--4">Pattern # 4</h3>
<p>The fourth and final pattern involves any scenario a Python developer writes a “<em>loop-and-a-half</em>” in their code to make up for the lack of a do-while loop in the language.</p>

<p>Let’s say I want to make burritos until I am out of ingredients:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_ingredients</span><span class="p">():</span>
    <span class="p">...</span>

<span class="k">def</span> <span class="nf">make_burritos_batch</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
    <span class="p">...</span>

<span class="n">burritos</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ingredients</span> <span class="o">=</span> <span class="n">get_ingredients</span><span class="p">()</span>               <span class="c1"># call get_ingredients()
</span><span class="k">while</span> <span class="n">ingredients</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">ingredients</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">burrito_batch</span> <span class="o">=</span> <span class="n">make_burrito_batch</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
        <span class="n">burritos</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">burrito_batch</span><span class="p">)</span>
    <span class="n">ingredients</span> <span class="o">=</span> <span class="n">get_ingredients</span><span class="p">()</span>          <span class="c1"># call get_ingredients() again
</span></code></pre></div></div>
<p>The obvious repetition above involves the two calls to <code class="language-plaintext highlighter-rouge">get_ingredients()</code>. We call it once before the while loop and then again at the end of the while loop to either restock the ingredients or break out of the loop.</p>

<p>One common way Python developers try to avoid this repetition is to use a “<em>loop-and-a-half</em>”. This strategy will get rid of the repetition but will make the while loop a simple infinite loop controlled by a <code class="language-plaintext highlighter-rouge">break</code> statement. Something we try to avoid. It is called a loop and a half because we execute half the code in the loop before exiting, instead of checking a proper condition first, thus never starting the terminal iteration to begin with.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">burritos</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>                                   <span class="c1"># loop
</span>    <span class="n">ingredients</span> <span class="o">=</span> <span class="n">get_ingredients</span><span class="p">()</span> 
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ingredients</span><span class="p">:</span>                       <span class="c1"># and a half
</span>        <span class="k">break</span>                                  
    <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">ingredients</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">burrito_batch</span> <span class="o">=</span> <span class="n">make_burrito_batch</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
        <span class="n">burritos</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">burrito_batch</span><span class="p">)</span>
</code></pre></div></div>
<p>We can avoid this awkward inifite loop with a break strategy with the walrus operator. Because the walrus operator allows us to assign a value in a conditional check, we do not need to initize ingredients before the loop, calling <code class="language-plaintext highlighter-rouge">get_ingredients()</code> twice. Nor do we need to implement a forever loop with a break statement. Instead we can reassign the ingredients variable and check it at each pass of the loop:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">burritos</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="n">ingredients</span> <span class="p">:</span><span class="o">=</span> <span class="n">get_ingredients</span><span class="p">():</span>                                   
    <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">ingredients</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">burrito_batch</span> <span class="o">=</span> <span class="n">make_burrito_batch</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
        <span class="n">burritos</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">burrito_batch</span><span class="p">)</span>
</code></pre></div></div>
<p>We can see in this example that it’s hard to argue that the walrus operator did not clean up this code. This is clean and Pythonic and does not require any ugly tricks.</p>

<p>Now we have seen 4 common patterns where the walrus operator comes in handy. So far, we are making a really strong case for assignment expressions. That being said, perhaps you are not convinced yet that there is real value in the walrus. I want to go over one more important area where the walrus operator is a nice addition.</p>

<h3 id="using-the-walrus-operator-in-comprehensions-to-keep-code-dry">Using the walrus operator in comprehensions to keep code DRY</h3>

<p>We all know what DRY means: Don’t Repeat Yourself. The idea is that if we are copy and pasting code, we probably should clean it up. Let’s say I am selling flowers at a flower shop and customers are buying flowers in batches of 8. To sell the flowers in these batches, I first want to see how many batches of 8 I can support from my total stock for each flower ordered:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flower_stock</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'rose'</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
    <span class="s">'tulip'</span><span class="p">:</span> <span class="mi">28</span><span class="p">,</span>
    <span class="s">'sunflow'</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
    <span class="s">'orchid'</span><span class="p">:</span> <span class="mi">12</span>
<span class="p">}</span>

<span class="n">flower_order</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tulip'</span><span class="p">,</span> <span class="s">'sunflower'</span><span class="p">,</span> <span class="s">'orchid'</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">get_flower_batches</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">count</span> <span class="o">//</span> <span class="n">size</span>

<span class="n">total_batches</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">flower</span> <span class="ow">in</span> <span class="n">flower_order</span><span class="p">:</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">flower_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">flower</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">num_batches</span> <span class="o">=</span> <span class="n">get_flower_batches</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_batches</span><span class="p">:</span>
        <span class="n">total_batches</span><span class="p">[</span><span class="n">flower</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_batches</span>

<span class="k">print</span><span class="p">(</span><span class="n">total_batches</span><span class="p">)</span>

<span class="c1"># {'tulip': 3, 'orchid': 1}
</span></code></pre></div></div>
<p>We could instead attempt write this more Pythonically with a dictionary comprehension:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">total_batches</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">flower</span><span class="p">:</span> <span class="n">get_flower_batches</span><span class="p">(</span><span class="n">flower_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">flower</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">flower</span> <span class="ow">in</span> <span class="n">flower_order</span>
    <span class="k">if</span> <span class="n">get_flower_batches</span><span class="p">(</span><span class="n">flower_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">flower</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This code really is not much better because the call to <code class="language-plaintext highlighter-rouge">get_flower_batches()</code> happens twice and it takes away from the readability of the code overall. This code would also not act as expected if we changed the actual parameters input to one of the two function calls but not the other.</p>

<p>The walrus operator can solve this problem:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">total_batches</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">flower</span> <span class="p">:</span> <span class="n">batches</span> <span class="k">for</span> <span class="n">flower</span> <span class="ow">in</span> <span class="n">flower_order</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">batches</span> <span class="p">:</span><span class="o">=</span> <span class="n">get_flower_batches</span><span class="p">(</span><span class="n">flower_stock</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">flower</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now our code looks really DRY. But is it better? To a long time Python developer the answer is probably yes. To someone who is newer to Python the answer might be no. This might look too cryptic to someone who is not used to this syntax.</p>

<hr />
<p><br /></p>

<p>Calling back to the original question: who was right about assignment expressions being a good addition, Guido or the critics? Let’s make a conclusion. We saw that there a number of instances where the walrus operator does improve readability. We could tell in our branching examples that it was clearer how to mentally scope some of our variables at a glance when we incorporated the walrus operator. And in our dictionary comprehension example, we can see that the walrus operator helped us keep our code DRY. On the other hand, some devs might find code which makes use of assignment expressions a bit too cryptic. They might say that such code is not what ‘Pythonic’ code is supposed to read like.</p>

<p>For me personally, I think Gudio was right. It is a good additon <em>when used correctly</em>.  One caveat, mentioned by Python core developer <a target="_blank" href="https://twitter.com/raymondh?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor">Raymond Hettinger</a> in the docs <a href="https://docs.python.org/3/whatsnew/3.8.html" target="_blank">‘What’s New in Python 3.8’</a>, is that we should:</p>
<blockquote>
  <p>Try to limit use of the walrus operator to clean cases that reduce complexity and improve readability.</p>
</blockquote>

<p>So in conclusion: there are places we ought to make the most of the walrus, but don’t go wild with it either. Be sensible. Be Pythonic.</p>

  </div><a class="u-url" href="/import-this/2021/02/15/when-and-how-to-use-assignment-expressions.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/import-this/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">import-this</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">import-this</li><li><a class="u-email" href="mailto:nicholashopewell@gmail.com">nicholashopewell@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/NHopewell"><svg class="svg-icon"><use xlink:href="/import-this/assets/minima-social-icons.svg#github"></use></svg> <span class="username">NHopewell</span></a></li><li><a href="https://www.twitter.com/NickHopewell"><svg class="svg-icon"><use xlink:href="/import-this/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">NickHopewell</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>I talk about Python. 🐍 </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
