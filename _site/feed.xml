<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/import-this/feed.xml" rel="self" type="application/atom+xml" /><link href="/import-this/" rel="alternate" type="text/html" /><updated>2021-02-14T17:18:31-05:00</updated><id>/import-this/feed.xml</id><title type="html">import-this</title><subtitle>This is my personal coding blog. As the name implies, I talk a lot about Python.</subtitle><entry><title type="html">Pythonic looping</title><link href="/import-this/2021/02/13/pythonic-looping.html" rel="alternate" type="text/html" title="Pythonic looping" /><published>2021-02-13T10:25:00-05:00</published><updated>2021-02-13T10:25:00-05:00</updated><id>/import-this/2021/02/13/pythonic-looping</id><content type="html" xml:base="/import-this/2021/02/13/pythonic-looping.html">&lt;p&gt;You’ve probably realized that Pythons most common for loop is actually a foreach loop. If you have an iterable data structure that you want to iterate through, you can loop over its items directly like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; names = 'nick sam ben larry'.split()
&amp;gt;&amp;gt;&amp;gt; for name in names:
...     print(name)
... 
nick
sam
ben
larry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;range()&lt;/code&gt; is a builtin which is nice for looping over a sequence of integers easily:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; for i in range(1, 11, 2):
...     print(i)
... 
1
3
5
7
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But its quite common to want to loop over all the items in a list while also keeping track of the index of each item. A non-pythonic
way to do this is to use range (which is meant for looping over integers) like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; for i in range(len(names)):
...     print(f&quot;{i}: {names[i]}&quot;)
... 
0: nick
1: sam
2: ben
3: larry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is needlessly clunky. We need to compute the length of the array and index into the array. As a rule of thumb, Pythonic syntax is beautiful and expressive. If the code looks clunky, it’s usually not the Pythonic way of doing things. Python does have a builtin specifically designed for this task: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enumerate()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enumerate()&lt;/code&gt; &lt;strong&gt;will wrap any iterator with a lazy generator&lt;/strong&gt; which will yield tuples each time next is called. The tuples that enumerate yields are the index of the item and the item itself. Like this: (index, item). We can keep calling next on our names list directly to see this in action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; names_enum = enumerate(names)
&amp;gt;&amp;gt;&amp;gt; print(next(names_enum))
(0, 'nick')
&amp;gt;&amp;gt;&amp;gt; print(next(names_enum))
(1, 'sam')
&amp;gt;&amp;gt;&amp;gt; print(next(names_enum))
(2, 'ben')
&amp;gt;&amp;gt;&amp;gt; print(next(names_enum))
(3, 'larry')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use a for loop to call next until stop iteration occurs, each loop yeilding these tuples, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; for i, name in enumerate(names):
...     print(f&quot;{i}: {name}&quot;)
... 
0: nick
1: sam
2: ben
3: larry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And something that many Python developers forget is that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enumerate()&lt;/code&gt; &lt;strong&gt;takes a second argument&lt;/strong&gt; which is the index to start with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; for i, name in enumerate(names, 1):
...     print(f&quot;{i}: {name}&quot;)
... 
1: nick
2: sam
3: ben
4: larry
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><summary type="html">You’ve probably realized that Pythons most common for loop is actually a foreach loop. If you have an iterable data structure that you want to iterate through, you can loop over its items directly like so:</summary></entry><entry><title type="html">Lists are not Arrays</title><link href="/import-this/2021/02/12/lists-are-not-arrays.html" rel="alternate" type="text/html" title="Lists are not Arrays" /><published>2021-02-12T10:25:00-05:00</published><updated>2021-02-12T10:25:00-05:00</updated><id>/import-this/2021/02/12/lists-are-not-arrays</id><content type="html" xml:base="/import-this/2021/02/12/lists-are-not-arrays.html">&lt;p&gt;I often hear new Python devs who come from other languages refer to Python lists as arrays. 
At first glance, this is not a big deal. Lists do behave just like arrays on the surface. They are both sliced in the same way, they are both accessed in the same way, they can both be extended and appended to in the same way, etc. But there are some very key differences between the two.&lt;/p&gt;

&lt;p&gt;The first difference is that lists can hold heterogenous data types. This means I can make a list mixed with ints, strings, and nested lists, like this one :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;my_ list = [1, 2, 'nick', [3, 'sam']]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This makes lists are more flexible than arrays as arrays are restricted to containing a single data type (usually ints or floats). But, this flexibility results in lists using a lot more memory than arrays.&lt;/p&gt;

&lt;p&gt;The flexibility of lists is so nice that some Python devs do not even know that Python has a C-style array, always opting for a list data structure instead.&lt;/p&gt;

&lt;p&gt;Here is how a double type array is allocated (the first argument denotes the type):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; import array
&amp;gt;&amp;gt;&amp;gt; new_array = array.array('d', [1, 2, 3, 4, 5])
&amp;gt;&amp;gt;&amp;gt; print(new_array)
array('d', [1.0, 2.0, 3.0, 4.0, 5.0])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Under the hood, lists and arrays are represented differently in memory. An array pointer points to the head of the array itself (the address of the first element of the array). And the array itself is a contiguous set of elements in memory. So just like an array in C, if we have a pointer to the head, along with the length of the array, we can easily operate on that array.&lt;/p&gt;

&lt;p&gt;Lists, on the other hand, do not contain elements which are contiguously arrange in memory. Instead, a list points to the head of a block of pointers. Each pointer in this block points to a complete Python object somewhere else in memory (each member of the list).&lt;/p&gt;

&lt;p&gt;This is shown below:
&lt;img src=&quot;../../../images/list_vs_array.png&quot; alt=&quot;list_pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;By pointing to the head of a pointer block, Python lists give the illusion of being contiguous in memory even though they do not have to be arranged as so.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So when should I use a list? When should I use an array?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Good question. Because lists do not need to be contiguous in memory nor of the same type, new elements can be appended very efficiently. If you believe your data structure will grow and shrink a lot, it makes sense to use a list. You should also use a list if you need to store many different data types.&lt;/p&gt;

&lt;p&gt;Arrays might be better to use if you need to store a large amount of one data type (typically numeric) and need to do computationally heavy math operations on the data. If you need to do a lot of math, I would recommend using the Numpy array as it is the most optimized data structure for this sort of task. The Numpy array is the data structure core to most Python machine learning libraries (which have to do a lot of linear algebra), and are the building blocks of the Pandas dataframe.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; import numpy as np
&amp;gt;&amp;gt;&amp;gt; numpy_array = np.array([1, 2, 3, 4, 5])
&amp;gt;&amp;gt;&amp;gt; print(numpy_array)
[1 2 3 4 5]
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><summary type="html">I often hear new Python devs who come from other languages refer to Python lists as arrays. At first glance, this is not a big deal. Lists do behave just like arrays on the surface. They are both sliced in the same way, they are both accessed in the same way, they can both be extended and appended to in the same way, etc. But there are some very key differences between the two.</summary></entry><entry><title type="html">The ‘is’ operator and the interpreter</title><link href="/import-this/2021/02/11/the-is-operator.html" rel="alternate" type="text/html" title="The ‘is’ operator and the interpreter" /><published>2021-02-11T10:25:00-05:00</published><updated>2021-02-11T10:25:00-05:00</updated><id>/import-this/2021/02/11/the-is-operator</id><content type="html" xml:base="/import-this/2021/02/11/the-is-operator.html">&lt;p&gt;The Python code below evaluates to True given a value of 256, but False when given a value of 257. But why?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; x = 256
&amp;gt;&amp;gt;&amp;gt; y = 256
&amp;gt;&amp;gt;&amp;gt; x is y
True

&amp;gt;&amp;gt;&amp;gt; x = 257
&amp;gt;&amp;gt;&amp;gt; y = 257
&amp;gt;&amp;gt;&amp;gt; x is y
False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, let’s talk about what &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is&lt;/code&gt; actually…is.&lt;/p&gt;

&lt;p&gt;Unlike &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt; which compares &lt;em&gt;values&lt;/em&gt; for equality, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is&lt;/code&gt; operator checks if both operands refer to the same object.  In other words, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is&lt;/code&gt; checks if the identity of both operands match or not. You can check this yourself with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; x = 256
&amp;gt;&amp;gt;&amp;gt; id(x)
4381006464
&amp;gt;&amp;gt;&amp;gt; y = 256
&amp;gt;&amp;gt;&amp;gt; id(y)
4381006464
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that these variables x and y are pointing to the same object in memory (they both have the same ids). This still does not make a lot of sense. If we do the same with a value of 257 given to x and y, we see that their ids are not the same anymore.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; x = 257
&amp;gt;&amp;gt;&amp;gt; id(x)
140476436035088
&amp;gt;&amp;gt;&amp;gt; y = 257
&amp;gt;&amp;gt;&amp;gt; id(y)
140476436034992
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So what’s going on here?&lt;/p&gt;

&lt;p&gt;The answer is that 256 is already an object when you launch python, while 257 is not. You can read this in the &lt;a href=&quot;https://docs.python.org/3/c-api/long.html&quot;&gt;documentation&lt;/a&gt;. It states:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So when we say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x = 256&lt;/code&gt; we are giving x a reference to an existing object. If we do the same for y, we get the same reference. But this is not true when we assign an integer to x or y which is outside of this range (-5 to 256).&lt;/p&gt;

&lt;p&gt;So why are only numbers from -5 to 256 stored as objects when you start Python? Simply because these are common numbers which are used a lot. It makes sense to have them already floating around for use.&lt;/p&gt;

&lt;p&gt;When we assign 257 to y right after assigning 257 to x, the interpreter does not know that we just created an integer with a value of 257, so it goes ahead and creates another object (with a different id). The same thing happens with immutable objects. Because lists are mutable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[] is []&lt;/code&gt; with always return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt; but if we do the same with empty tuples (which are immutable), we see that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;() is ()&lt;/code&gt; will return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But it gets even more interesting when we &lt;strong&gt;initialize two variables with the same value on the same line&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&amp;gt;&amp;gt;&amp;gt; x, y = 257, 257
&amp;gt;&amp;gt;&amp;gt; x is y
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, for some reason, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x is y&lt;/code&gt; returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt; when both are given a value of 257. Which was not the case when we assigned 257 to these variables on different lines.&lt;/p&gt;

&lt;p&gt;Like previously mentioned, when we set x and y to 257 on different lines, the interpreter doesn’t know we already created this object in memory and so a new one is created. But, when we do this all on one line, Python creates a new object AND references the second variable (y) at the same time. Thus giving both x and y a reference to the same object with the same id. Which explains why the is operator acts like it does.&lt;/p&gt;

&lt;p&gt;The explaination for this is one of optimization within an interactive environment (like a repr). When 2 lines are entered into the interpreter they are handled separately, and optimized separately. If you tried to reconstruct this experiment within a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.py&lt;/code&gt; file and run it, this behaviour would not happen. It wouldn’t happen because the optimization outside of an interactive environment, such as running an entire script, works holistically.&lt;/p&gt;</content><author><name></name></author><summary type="html">The Python code below evaluates to True given a value of 256, but False when given a value of 257. But why?</summary></entry></feed>